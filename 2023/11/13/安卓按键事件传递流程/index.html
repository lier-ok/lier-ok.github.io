

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/cute_icon.png">
  <link rel="icon" href="/img/cute_icon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="lier">
  <meta name="keywords" content="">
  
  <title>安卓按键事件传递流程 - Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.9","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>lier的博客</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/background.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="安卓按键事件传递流程">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2023-11-13 18:07" pubdate>
        2023年11月13日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      5.9k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      87
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">安卓按键事件传递流程</h1>
            
            <div class="markdown-body">
              <h3 id="安卓按键事件传递流程"><a href="#安卓按键事件传递流程" class="headerlink" title="安卓按键事件传递流程"></a>安卓按键事件传递流程</h3><h4 id="1-Framework层如何获得输入事件"><a href="#1-Framework层如何获得输入事件" class="headerlink" title="1.Framework层如何获得输入事件"></a>1.Framework层如何获得输入事件</h4><h6 id="1-1：-InputManagerService的初始化"><a href="#1-1：-InputManagerService的初始化" class="headerlink" title="1.1： InputManagerService的初始化"></a>1.1： <strong>InputManagerService</strong>的初始化</h6><p>​		**SystemServer ** (frameworks&#x2F;base&#x2F;services&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;SystemServer.java)</p>
<p>​		安卓系统启动时，首先创建<strong>SystemServer对象，随后初始化了</strong>InputManagerService**</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在SystemServer的main方法中的调用run()方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">SystemServer</span>().run();<br>&#125;<br><span class="hljs-comment">//在run()方法中调用 startOtherServices(@NonNull TimingsTraceAndSlog t) 方法</span><br>startOtherServices(t);<br><br><span class="hljs-comment">// 在startOtherServices方法中初始化InputManagerService</span><br><span class="hljs-comment">//关于初始化InputManagerService的部分</span><br><br>t.traceBegin(<span class="hljs-string">&quot;StartInputManagerService&quot;</span>);<br>inputManager = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputManagerService</span>(context);<br>t.traceEnd();<br>wm = WindowManagerService.main(context, inputManager, !mFirstBoot, mOnlyCore,<span class="hljs-keyword">new</span> <span class="hljs-title class_">PhoneWindowManager</span>(), mActivityManagerService.mActivityTaskManager)<br>ServiceManager.addService(Context.INPUT_SERVICE, inputManager, <span class="hljs-literal">false</span>, DUMP_FLAG_PRIORITY_CRITICAL);<br>inputManager.setWindowManagerCallbacks(wm.getInputManagerCallback());<br>inputManager.start();<br><br></code></pre></td></tr></table></figure>



<h6 id="1-2：InputManagerService构造器"><a href="#1-2：InputManagerService构造器" class="headerlink" title="1.2：InputManagerService构造器"></a>1.2：InputManagerService构造器</h6><p>​	InputManagerService(framework&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;input&#x2F;InputManagerService.java)</p>
<p>​	上述代码中，使用了new InputManagerService(context)这个构造器，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">InputManagerService</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-built_in">this</span>.mContext = context;<br>        <span class="hljs-built_in">this</span>.mHandler = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputManagerHandler</span>(DisplayThread.get().getLooper());<br><br>        mStaticAssociations = loadStaticInputPortAssociations();<br>        mUseDevInputEventForAudioJack =<br>        context.getResources().getBoolean(R.bool.config_useDevInputEventForAudioJack);<br>        Slog.i(TAG, <span class="hljs-string">&quot;Initializing input manager, mUseDevInputEventForAudioJack=&quot;</span><br>        + mUseDevInputEventForAudioJack);<br>        mPtr = nativeInit(<span class="hljs-built_in">this</span>, mContext, mHandler.getLooper().getQueue());<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">doubleTouchGestureEnablePath</span> <span class="hljs-operator">=</span> context.getResources().getString(<br>        R.string.config_doubleTouchGestureEnableFile);<br>        mDoubleTouchGestureEnableFile = TextUtils.isEmpty(doubleTouchGestureEnablePath) ? <span class="hljs-literal">null</span> :<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(doubleTouchGestureEnablePath);<br><br>        LocalServices.addService(InputManagerInternal.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalService</span>());<br>&#125;<br></code></pre></td></tr></table></figure>



<p>创建了一个InputManagerHandler对象，参数是HandlerThread中创建的looper对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">this</span>.mHandler = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputManagerHandler</span>(DisplayThread.get().getLooper());<br></code></pre></td></tr></table></figure>

<p>用Looper中的消息队列作为参数，调用本地方法nativeInit，返回C++中的NativeInputManager对象地址赋给<strong>mPtr</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">mPtr = nativeInit(<span class="hljs-built_in">this</span>, mContext, mHandler.getLooper().getQueue());<br></code></pre></td></tr></table></figure>

<p>将InputManagerInternal.class和LocalService对象作为一对映射添加到ArrayMap&lt;Class&lt;?&gt;, Object&gt;中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">LocalServices.addService(InputManagerInternal.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalService</span>());<br></code></pre></td></tr></table></figure>



<h6 id="1-3：nativeInit方法"><a href="#1-3：nativeInit方法" class="headerlink" title="1.3：nativeInit方法"></a>1.3：nativeInit方法</h6><p>放回NativeInputManager的引用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-title function_">jlongnativeInit</span><span class="hljs-params">(JNIEnv* env, jclassclazz,</span><br><span class="hljs-params">        jobjectserviceObj, jobjectcontextObj, jobjectmessageQueueObj)</span> &#123;<br>    sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj);<br>    <span class="hljs-keyword">if</span> (messageQueue == <span class="hljs-literal">NULL</span>) &#123;<br>        jniThrowRuntimeException(env, <span class="hljs-string">&quot;MessageQueue is not initialized.&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br> <br>    NativeInputManager* im = new NativeInputManager(contextObj, serviceObj,<br>            messageQueue-&gt;getLooper());<br>    im-&gt;incStrong(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> reinterpret_cast&lt;jlong&gt;(im);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>android_os_MessageQueue_getMessageQueue()方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">sp&lt;MessageQueue&gt; <span class="hljs-title">android_os_MessageQueue_getMessageQueue</span><span class="hljs-params">(JNIEnv* env, jobjectmessageQueueObj)</span> </span>&#123;<br>    jlongptr = env-&gt;<span class="hljs-built_in">GetLongField</span>(messageQueueObj, gMessageQueueClassInfo.mPtr);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>GetLongField()</code> 方法获取 Java 层消息队列对象的 <code>mPtr</code> 域。该域存储了本地消息队列对象的指针</p>
<p><strong>在 JNI 开发中，我们使用 <code>GetLongField</code> 函数来获取 Java 对象的 long 类型字段值</strong></p>
<p>获取到的指针转换为 <code>NativeMessageQueue</code> 对象的指针，创建一个消息队列的本地代理对象 <code>sp&lt;MessageQueue&gt;</code> 并将其返回</p>
<p>在此处就获得了native层的NativeMessageQueue对象，因为<strong>NativeMessageQueue在Looper对象初始化时，就被创建</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">NativeInputManager* im = <span class="hljs-keyword">new</span> <span class="hljs-built_in">NativeInputManager</span>(contextObj, serviceObj,<br>           messageQueue-&gt;<span class="hljs-built_in">getLooper</span>());<br></code></pre></td></tr></table></figure>



<h6 id="1-4-NativeMessageQueue创建时机"><a href="#1-4-NativeMessageQueue创建时机" class="headerlink" title="1.4: NativeMessageQueue创建时机"></a>1.4: NativeMessageQueue创建时机</h6><p>那么NativeMessageQueue时怎么在Looper对象被创建的时候创建的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepare</span><span class="hljs-params">(<span class="hljs-type">boolean</span> quitAllowed)</span> &#123;<br>    <span class="hljs-keyword">if</span> (sThreadLocal.get() != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Only one Looper may be created per thread&quot;</span>);<br>    &#125;<br>  	<span class="hljs-comment">//new 了一个 Looper 对象,将这个 Looper 对象写入 ThreadLocal 中</span><br>    sThreadLocal.set(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Looper</span>(quitAllowed));<br>&#125;<br><br><span class="hljs-comment">//上述new Looper 使用了该构造函数, 在该函数中调用了MessageQueue的构造函数,初始化java层的MessageQueue对象</span><br><span class="hljs-keyword">private</span> <span class="hljs-title function_">Looper</span><span class="hljs-params">(<span class="hljs-type">boolean</span> quitAllowed)</span> &#123;<br>    <span class="hljs-comment">// 创建了一个消息队列</span><br>    mQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageQueue</span>(quitAllowed);<br>    <span class="hljs-comment">// 获取了当前的线程</span><br>    mThread = Thread.currentThread();<br> &#125;<br><br><span class="hljs-comment">// MessageQueue构造函数中调用了nativeInit方法</span><br>MessageQueue(<span class="hljs-type">boolean</span> quitAllowed) &#123;<br>    mQuitAllowed = quitAllowed;<br>    mPtr = nativeInit();<br>&#125;<br><br><span class="hljs-comment">//c++ 层的代码中就初始化了一个NativeMessageQueue的指针，并返回存储在 Java 层消息队列对象的 `mPtr` 域</span><br><span class="hljs-keyword">static</span> jlong <span class="hljs-title function_">android_os_MessageQueue_nativeInit</span><span class="hljs-params">(JNIEnv* env, jclass clazz)</span> &#123;<br>    NativeMessageQueue* nativeMessageQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NativeMessageQueue</span>();<br>    <span class="hljs-keyword">if</span> (!nativeMessageQueue) &#123;<br>        jniThrowRuntimeException(env, <span class="hljs-string">&quot;Unable to allocate native queue&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    nativeMessageQueue-&gt;incStrong(env);<br>    <span class="hljs-keyword">return</span> reinterpret_cast&lt;jlong&gt;(nativeMessageQueue);<br>&#125;<br></code></pre></td></tr></table></figure>



<h6 id="1-5-EventHub和InputManager初始化"><a href="#1-5-EventHub和InputManager初始化" class="headerlink" title="1.5: EventHub和InputManager初始化"></a>1.5: EventHub和InputManager初始化</h6><p>在NativeMessageQueue的构造函数中，将Looper对象赋值给了mLooper, 并创建mContextObj和mServiceObj全局变量</p>
<p>并实例化EventHub和InputManager对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++">NativeInputManager::<span class="hljs-built_in">NativeInputManager</span>(jobjectcontextObj,<br>        jobjectserviceObj, <span class="hljs-type">const</span> sp&lt;Looper&gt;&amp; looper) :<br>        <span class="hljs-built_in">mLooper</span>(looper), <span class="hljs-built_in">mInteractive</span>(<span class="hljs-literal">true</span>) &#123;<br>    JNIEnv* env = <span class="hljs-built_in">jniEnv</span>();<br> <br>    mContextObj = env-&gt;<span class="hljs-built_in">NewGlobalRef</span>(contextObj);<br>    mServiceObj = env-&gt;<span class="hljs-built_in">NewGlobalRef</span>(serviceObj);<br> <br>    &#123;<br>        <span class="hljs-built_in">AutoMutex_l</span>(mLock);<br>        mLocked.systemUiVisibility = ASYSTEM_UI_VISIBILITY_STATUS_BAR_VISIBLE;<br>        mLocked.pointerSpeed = <span class="hljs-number">0</span>;<br>        mLocked.pointerGesturesEnabled = <span class="hljs-literal">true</span>;<br>        mLocked.showTouches = <span class="hljs-literal">false</span>;<br>    &#125;<br> <br>    sp&lt;EventHub&gt; eventHub = <span class="hljs-keyword">new</span> <span class="hljs-built_in">EventHub</span>(); <span class="hljs-comment">//创建ExentHUb对象</span><br>            <br>    <span class="hljs-comment">//在EventHub的构造函数中</span><br>    <span class="hljs-comment">//1.mEpollFd = epoll_create(EPOLL_SIZE_HINT);采用epoll机制系统调用接口epoll_create创建epoll对象，返回文件描述符</span><br>    <span class="hljs-comment">//2. mINotifyFd = inotify_init()</span><br>    <span class="hljs-comment">//	 int result = inotify_add_watch(mINotifyFd, DEVICE_PATH, IN_DELETE | IN_CREATE);</span><br>    <br>    <span class="hljs-comment">//采用inotify机制监听文件或目录的移动、读取、写入或删除等事件，inotify机制主要包含2个系统调用接口：inotify_init, 			inotify_add_watch</span><br><br>	<span class="hljs-comment">//inotify_init：创建一个inotify对象，如果成功，返回一个文件描述符，作为该对象；返回-1表示出错</span><br><br>	<span class="hljs-comment">//int result = inotify_add_watch(mINotifyFd, DEVICE_PATH, IN_DELETE | IN_CREATE)</span><br>	<span class="hljs-comment">//把监控项添加到mINotifyFd对象的监控列表中，第二个参数DEVICE_PATH就是被监控对象，该对象一般是文件或目录，本文中被监控的		//DEVICE_PATH就是/dev/input目录；第三个参数是一个位掩码，表示被监控对象上发生的具体事件，可以由1个或多个掩码位或门组成。	//IN_DELETE：当被监控目录内删除文件或目录时触发该事件；IN_CREATE：当被监控目录内创建文件或目录时触发该事件。比如，插入、	  //拔出鼠标时，就会触发该事件</span><br><br>    mInputManager = <span class="hljs-keyword">new</span> <span class="hljs-built_in">InputManager</span>(eventHub, <span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="D:\project\bolg\source_posts\安卓按键事件传递流程.assets\Snipaste_2023-12-08_10-38-39.png" srcset="/img/loading.gif" lazyload alt="Snipaste_2023-12-08_10-38-39"></p>
<p>图中是创建EventHub时，会监听的目录文件</p>
<p><strong>InputManager的构造函数</strong></p>
<p>在该构造函数中，创建了InputDispatcher和InputReader对象，再调用initialize方法分别创建了与InputDispatcher和InputReader对应的线程<strong>InputDispatcherThread</strong>和<strong>InputReaderThread</strong>对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++">InputManager::<span class="hljs-built_in">InputManager</span>(<br>    <span class="hljs-type">const</span> sp&lt;EventHubInterface&gt;&amp; eventHub,<br>    <span class="hljs-type">const</span> sp&lt;InputReaderPolicyInterface&gt;&amp; readerPolicy,<br>    <span class="hljs-type">const</span> sp&lt;InputDispatcherPolicyInterface&gt;&amp; dispatcherPolicy) &#123;<br>    mDispatcher = <span class="hljs-keyword">new</span> <span class="hljs-built_in">InputDispatcher</span>(dispatcherPolicy);<br>    mReader = <span class="hljs-keyword">new</span> <span class="hljs-built_in">InputReader</span>(eventHub, readerPolicy, mDispatcher);<br>    <span class="hljs-built_in">initialize</span>();<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InputManager::initialize</span><span class="hljs-params">()</span> </span>&#123;<br>    mReaderThread = <span class="hljs-keyword">new</span> <span class="hljs-built_in">InputReaderThread</span>(mReader);<br>    mDispatcherThread = <span class="hljs-keyword">new</span> <span class="hljs-built_in">InputDispatcherThread</span>(mDispatcher);<br>&#125;<br></code></pre></td></tr></table></figure>



<h6 id="1-6-上述问题总结"><a href="#1-6-上述问题总结" class="headerlink" title="1.6:上述问题总结"></a>1.6:上述问题总结</h6><p>​		1：epoll机制中，一般有般有3个系统调用接口，epoll_create, epoll_ctl，epoll_wait，而目前只在EventHub的构造函数中使用epoll_create和epoll_ctl方法， 猜测在代码某处肯定有epoll_wait，否则epoll机制无法工作</p>
<p>​		2：在InpuManager的initialize中创建的两个线程InputReaderThread，InputDispatcherThread， 但是没有start</p>
<h6 id="1-7-WindowManagerService的main方法"><a href="#1-7-WindowManagerService的main方法" class="headerlink" title="1.7:WindowManagerService的main方法"></a>1.7:WindowManagerService的main方法</h6><p>​	在1.1中SystemServer调用startOtherServices()方法时,调用了WindowManagerService的main方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">wm = WindowManagerService.main(context, inputManager, !mFirstBoot, mOnlyCore,<span class="hljs-keyword">new</span> <span class="hljs-title class_">PhoneWindowManager</span>(), mActivityManagerService.mActivityTaskManager)<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> WindowManagerService <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Context context,<span class="hljs-keyword">final</span> InputManagerService im,<span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> haveInputMethods, <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> showBootMsgs,<span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> onlyCore)</span> &#123;<br>    <span class="hljs-keyword">final</span> WindowManagerService[] holder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WindowManagerService</span>[<span class="hljs-number">1</span>];<br>    DisplayThread.getHandler().runWithScissors(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">//在该构造函数中将im(ImputManager)赋值给mInputManager</span><br>            <span class="hljs-comment">// mInputManager = inputManager</span><br>            holder[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WindowManagerService</span>(context, im,haveInputMethods, showBootMsgs, onlyCore); <br>        &#125;<br>    &#125;, <span class="hljs-number">0</span>);<br> 	<span class="hljs-keyword">return</span> holder[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure>



<h6 id="1-8-ServiceManager的addService方法"><a href="#1-8-ServiceManager的addService方法" class="headerlink" title="1.8:ServiceManager的addService方法"></a>1.8:ServiceManager的addService方法</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">ServiceManager<span class="hljs-selector-class">.addService</span>(Context<span class="hljs-selector-class">.INPUT_SERVICE</span>, inputManager);<br></code></pre></td></tr></table></figure>

<p>把InputManagerService服务注册到ServiceManager中</p>
<h6 id="1-9-InputManagerService的setWindowManagerCallbacks方法"><a href="#1-9-InputManagerService的setWindowManagerCallbacks方法" class="headerlink" title="1.9:InputManagerService的setWindowManagerCallbacks方法"></a>1.9:InputManagerService的setWindowManagerCallbacks方法</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">inputManager<span class="hljs-selector-class">.setWindowManagerCallbacks</span>(wm<span class="hljs-selector-class">.getInputMonitor</span>());<br></code></pre></td></tr></table></figure>

<p>把InputMonitor对象传递到InputManagerService中去，便于回调</p>
<h6 id="1-10-InputManagerService-start-方法"><a href="#1-10-InputManagerService-start-方法" class="headerlink" title="1.10:InputManagerService.start()方法"></a>1.10:InputManagerService.start()方法</h6><p>InputManagerService  (frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;input&#x2F;InputManagerService.java)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">inputManager.start();<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>    Slog.i(TAG, <span class="hljs-string">&quot;Starting input manager&quot;</span>);<br>    nativeStart(mPtr);<br><br>    <span class="hljs-comment">// Add ourself to the Watchdog monitors.</span><br>    Watchdog.getInstance().addMonitor(<span class="hljs-built_in">this</span>);<br><br>    registerPointerSpeedSettingObserver();<br>    registerShowTouchesSettingObserver();<br>    registerAccessibilityLargePointerSettingObserver();<br>    registerLongPressTimeoutObserver();<br>    registerMaximumObscuringOpacityForTouchSettingObserver();<br>    registerBlockUntrustedTouchesModeSettingObserver();<br><br>    mContext.registerReceiver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BroadcastReceiver</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onReceive</span><span class="hljs-params">(Context context, Intent intent)</span> &#123;<br>            updatePointerSpeedFromSettings();<br>            updateShowTouchesFromSettings();<br>            updateAccessibilityLargePointerFromSettings();<br>            updateDeepPressStatusFromSettings(<span class="hljs-string">&quot;user switched&quot;</span>);<br>        &#125;<br>    &#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntentFilter</span>(Intent.ACTION_USER_SWITCHED), <span class="hljs-literal">null</span>, mHandler);<br><br>    updatePointerSpeedFromSettings();<br>    updateShowTouchesFromSettings();<br>    updateAccessibilityLargePointerFromSettings();<br>    updateDeepPressStatusFromSettings(<span class="hljs-string">&quot;just booted&quot;</span>);<br>    updateMaximumObscuringOpacityForTouchFromSettings();<br>    updateBlockUntrustedTouchesModeFromSettings();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中有两行代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">nativeStart(mPtr);<br><br><span class="hljs-comment">// Add ourself to the Watchdog monitors.</span><br>Watchdog.getInstance().addMonitor(<span class="hljs-built_in">this</span>);<br></code></pre></td></tr></table></figure>

<p>nativeStart()方法，将mPtr转为NativeInputManager指针，启动InputManager</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">nativeStart</span><span class="hljs-params">(JNIEnv* env, jclassclazz, jlongptr)</span> </span>&#123;<br>    NativeInputManager* im = <span class="hljs-built_in">reinterpret_cast</span>&lt;NativeInputManager*&gt;(ptr);<br> <br>    status_tresult = im-&gt;<span class="hljs-built_in">getInputManager</span>()-&gt;<span class="hljs-built_in">start</span>();<br>    <span class="hljs-keyword">if</span> (result) &#123;<br>        <span class="hljs-built_in">jniThrowRuntimeException</span>(env, <span class="hljs-string">&quot;Input manager could not be started.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>im-&gt;getInputManager()-&gt;start()方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">InputManager::start</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    <span class="hljs-type">status_t</span> result = mDispatcherThread-&gt;<span class="hljs-built_in">run</span>(<span class="hljs-string">&quot;InputDispatcher&quot;</span>, PRIORITY_URGENT_DISPLAY);<br>    <br>    <span class="hljs-keyword">if</span> (result) &#123;<br>        <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;Could not start InputDispatcher thread due to error %d.&quot;</span>, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br> <br>    result = mReaderThread-&gt;<span class="hljs-built_in">run</span>(<span class="hljs-string">&quot;InputReader&quot;</span>, PRIORITY_URGENT_DISPLAY);<br>    <span class="hljs-keyword">if</span> (result) &#123;<br>        <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;Could not start InputReader thread due to error %d.&quot;</span>, result);<br> <br>        mDispatcherThread-&gt;<span class="hljs-built_in">requestExit</span>();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br> <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到在这里，先启动了分发器线程<code>InputDispatcherThread</code>, 再启动<code>InputReaderThread</code>接收器线程， <strong>回答1.6中的问题2</strong></p>
<p>在安卓框架中，<code>run()</code>方法用于启动一个线程，并在新线程中执行<code>threadLoop()</code>方法</p>
<p>在<code>InputDispatcherThread</code> -&gt;threadLoop()方法中调用了mDispatcher-&gt;dispatchOnce()</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InputDispatcher::dispatchOnce</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">nsecs_t</span> nextWakeupTime = LONG_LONG_MAX;<br>    &#123; <br>        std::scoped_lock _l(mLock);<br>        mDispatcherIsAlive.<span class="hljs-built_in">notify_all</span>();<br><br>  <br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">haveCommandsLocked</span>()) &#123;<br>            <span class="hljs-built_in">dispatchOnceInnerLocked</span>(&amp;nextWakeupTime);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">runCommandsLockedInterruptible</span>()) &#123;<br>            nextWakeupTime = LONG_LONG_MIN;<br>        &#125;<br><br>        <span class="hljs-type">const</span> <span class="hljs-type">nsecs_t</span> nextAnrCheck = <span class="hljs-built_in">processAnrsLocked</span>();<br>        nextWakeupTime = std::<span class="hljs-built_in">min</span>(nextWakeupTime, nextAnrCheck);<br><br>        <span class="hljs-keyword">if</span> (nextWakeupTime == LONG_LONG_MAX) &#123;<br>            mDispatcherEnteredIdle.<span class="hljs-built_in">notify_all</span>();<br>        &#125;<br>    &#125; <br>    <br>    <span class="hljs-type">nsecs_t</span> currentTime = <span class="hljs-built_in">now</span>();<br>    <span class="hljs-type">int</span> timeoutMillis = <span class="hljs-built_in">toMillisecondTimeoutDelay</span>(currentTime, nextWakeupTime);<br>    mLooper-&gt;<span class="hljs-built_in">pollOnce</span>(timeoutMillis);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>开始阶段，在CommandQueue中没有命令，所以执行代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">haveCommandsLocked</span>()) &#123;<br>	<span class="hljs-built_in">dispatchOnceInnerLocked</span>(&amp;nextWakeupTime);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InputDispatcher::haveCommandsLocked</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> !mCommandQueue.<span class="hljs-built_in">empty</span>(); <span class="hljs-comment">//开始阶段数据为空，返回false</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h6 id="1-11-InputDispatcher-cpp的dispatchOnceInnerLocked"><a href="#1-11-InputDispatcher-cpp的dispatchOnceInnerLocked" class="headerlink" title="1.11:InputDispatcher.cpp的dispatchOnceInnerLocked"></a>1.11:InputDispatcher.cpp的dispatchOnceInnerLocked</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InputDispatcher::dispatchOnceInnerLocked</span><span class="hljs-params">(<span class="hljs-type">nsecs_t</span>* nextWakeupTime)</span> </span>&#123;<br>    ....<br>    ....<br>    <br>    <span class="hljs-comment">//初始化时，mPendingEvent为空，mInboundQueue队列也为空</span><br>    <span class="hljs-keyword">if</span> (!mPendingEvent) &#123;<br>        <span class="hljs-keyword">if</span> (mInboundQueue.<span class="hljs-built_in">empty</span>()) &#123; <br>            <br>            <span class="hljs-comment">//如果isAppSwitchDue为true，表明切换按键(比如HOME、拨号键)的执行时间还没有			  //到，系统就自动放弃这一次的按键处理，并把isAppSwitchDue设置false</span><br>            <span class="hljs-keyword">if</span> (isAppSwitchDue) &#123;<br>                <span class="hljs-built_in">resetPendingAppSwitchLocked</span>(<span class="hljs-literal">false</span>);<br>                isAppSwitchDue = <span class="hljs-literal">false</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//mKeyRepeatState.lastKeyEntry初始化为false,跳过</span><br>            <span class="hljs-keyword">if</span> (mKeyRepeatState.lastKeyEntry) &#123;<br>                <span class="hljs-keyword">if</span> (currentTime &gt;= mKeyRepeatState.nextRepeatTime) &#123;<br>                    mPendingEvent = <span class="hljs-built_in">synthesizeKeyRepeatLocked</span>(currentTime);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (mKeyRepeatState.nextRepeatTime &lt; *nextWakeupTime) &#123;<br>                        *nextWakeupTime = mKeyRepeatState.nextRepeatTime;<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>          	<span class="hljs-comment">//结束</span><br>            <span class="hljs-keyword">if</span> (!mPendingEvent) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <br>            <span class="hljs-comment">//当mInboundQueue之中至少有一条数据时</span><br>            mPendingEvent = mInboundQueue.<span class="hljs-built_in">front</span>();<br>            mInboundQueue.<span class="hljs-built_in">pop_front</span>();<br>            <span class="hljs-comment">// 创建iq标签，跟踪记录mInboundQueue的size</span><br>            <span class="hljs-built_in">traceInboundQueueLengthLocked</span>();<br>        &#125;<br><br><br>        <span class="hljs-keyword">if</span> (mPendingEvent-&gt;policyFlags &amp; POLICY_FLAG_PASS_TO_USER) &#123;<br>            <span class="hljs-built_in">pokeUserActivityLocked</span>(*mPendingEvent);<br>        &#125;<br>    &#125;<br>    <br>    ....<br>    ....<br>&#125;<br></code></pre></td></tr></table></figure>

<p>由于mPendingEvent在初始化时为空，所以代码在这里返回</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//结束</span><br><span class="hljs-keyword">if</span> (!mPendingEvent) &#123;<br>	<span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>回到上层方法dispatchOnce中，继续执行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">runCommandsLockedInterruptible</span>()) &#123; <span class="hljs-comment">//false; 跳过</span><br>    nextWakeupTime = LONG_LONG_MIN;<br>&#125;<br><br><span class="hljs-comment">//一开始，没有命令待处理，runCommandsLockedInterruptible返回false，跳过语句；如果有</span><br><span class="hljs-comment">//命令的话，就取出来处理</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InputDispatcher::runCommandsLockedInterruptible</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mCommandQueue.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">do</span> &#123;<br>        std::unique_ptr&lt;CommandEntry&gt; commandEntry = std::<span class="hljs-built_in">move</span>(mCommandQueue.<span class="hljs-built_in">front</span>());<br>        mCommandQueue.<span class="hljs-built_in">pop_front</span>();<br>        Command command = commandEntry-&gt;command;<br>        <span class="hljs-built_in">command</span>(*<span class="hljs-keyword">this</span>, commandEntry.<span class="hljs-built_in">get</span>()); <span class="hljs-comment">// commands are implicitly &#x27;LockedInterruptible&#x27;</span><br><br>        commandEntry-&gt;connection.<span class="hljs-built_in">clear</span>();<br>    &#125; <span class="hljs-keyword">while</span> (!mCommandQueue.<span class="hljs-built_in">empty</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>在dispatchOnce方法最后，执行mLooper-&gt;pollOnce(timeoutMillis)</strong></p>
<h6 id="1-12-Looper的pollOnce-timeoutMills"><a href="#1-12-Looper的pollOnce-timeoutMills" class="headerlink" title="1.12:Looper的pollOnce(timeoutMills)"></a>1.12:Looper的pollOnce(timeoutMills)</h6><p>​		pollOnce一直执行到epoll_wait监控管道读取端，如果管道有I&#x2F;O事件发生，epoll_wait就会返回发生事件的个数；如果还没有事件，进程InputDispatcherThread在此等待</p>
<p>​		EventHub监听路径时，其构造函数中使用了epoll_create和epoll_ctl, 这里pollOnce一直执行到epoll_wait监控I&#x2F;O事件的发生，到此epoll机制的三个函数均被调用，<strong>回答1.6的问题1</strong></p>
<p>那么在这里使用了这个pollOnce阻塞等待的方法，那么是在哪里被唤醒呢？</p>
<h6 id="1-13-InputReader的loopOnce"><a href="#1-13-InputReader的loopOnce" class="headerlink" title="1.13:InputReader的loopOnce()"></a>1.13:InputReader的loopOnce()</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InputReader::loopOnce</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    int32_toldGeneration;<br>    int32_ttimeoutMillis;<br>    <span class="hljs-type">bool</span> inputDevicesChanged = <span class="hljs-literal">false</span>;<br>    Vector&lt;InputDeviceInfo&gt; inputDevices;<br>    <br>    &#123; <br>        <span class="hljs-built_in">AutoMutex_l</span>(mLock);<br> <br>        oldGeneration = mGeneration;<br>        timeoutMillis = <span class="hljs-number">-1</span>;<br> <br>        uint32_tchanges = mConfigurationChangesToRefresh;<br>        <span class="hljs-keyword">if</span> (changes) &#123;<br>            mConfigurationChangesToRefresh = <span class="hljs-number">0</span>;<br>            timeoutMillis = <span class="hljs-number">0</span>;<br>            <span class="hljs-built_in">refreshConfigurationLocked</span>(changes);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mNextTimeout != LLONG_MAX) &#123;<br>            nsecs_tnow = <span class="hljs-built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC);<br>            timeoutMillis = <span class="hljs-built_in">toMillisecondTimeoutDelay</span>(now, mNextTimeout);<br>        &#125;<br>    &#125; <br> <br>    size_tcount = mEventHub-&gt;<span class="hljs-built_in">getEvents</span>(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);<br> <br>    &#123; <br>        <span class="hljs-built_in">AutoMutex_l</span>(mLock);<br>        mReaderIsAliveCondition.<span class="hljs-built_in">broadcast</span>();<br> <br>        <span class="hljs-keyword">if</span> (count) &#123;<br>            <span class="hljs-built_in">processEventsLocked</span>(mEventBuffer, count);<br>        &#125;<br> <br>        <span class="hljs-keyword">if</span> (mNextTimeout != LLONG_MAX) &#123;<br>            nsecs_tnow = <span class="hljs-built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC);<br>            <span class="hljs-keyword">if</span> (now &gt;= mNextTimeout) &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DEBUG_RAW_EVENTS</span><br>                <span class="hljs-built_in">ALOGD</span>(<span class="hljs-string">&quot;Timeout expired, latency=%0.3fms&quot;</span>, (now - mNextTimeout) * <span class="hljs-number">0.000001f</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>                mNextTimeout = LLONG_MAX;<br>                <span class="hljs-built_in">timeoutExpiredLocked</span>(now);<br>            &#125;<br>        &#125;<br> <br>        <span class="hljs-keyword">if</span> (oldGeneration != mGeneration) &#123;<br>            inputDevicesChanged = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">getInputDevicesLocked</span>(inputDevices);<br>        &#125;<br>    &#125; <br> <br><br>    <span class="hljs-keyword">if</span> (inputDevicesChanged) &#123;<br>        mPolicy-&gt;<span class="hljs-built_in">notifyInputDevicesChanged</span>(inputDevices);<br>    &#125;<br><br>    mQueuedListener-&gt;<span class="hljs-built_in">flush</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>InputDeviceInfo：描述输入设备特征和特性的类</p>
<p>getEvents用来获取输入设备信息、输入事件；processEventsLocked用来处理获得的事件的；按照顺序，首先进入到getEvents</p>
<h6 id="1-14-EventHub的getEvents-函数"><a href="#1-14-EventHub的getEvents-函数" class="headerlink" title="1.14: EventHub的getEvents()函数"></a>1.14: EventHub的getEvents()函数</h6><p>参数RawEvent* buffer：存储底层上报的输入事件，因为包含各种事件，没有过滤，称为原始事件</p>
<p>参数bufferSize：已分配input_event的buffer大小，256字节，input_event是所获取事件的结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">input_event</span> &#123;</span><br>    <br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timevaltime</span>;</span> <span class="hljs-comment">//事件的执行时间</span><br>    <br> __u16 type; <span class="hljs-comment">//事件类型，EV_KEY(按键)，EV_ABS(绝对坐标，如触摸屏)，EV_REL(相对坐标,轨			   //迹，如鼠标)等</span><br>    <br> __u16 code; <span class="hljs-comment">//如果type是按键，code表示原始按键码值；如果是EV_REL，code表示轨迹类型，包			 //括REL_X(X轴方向)，REL_Y(Y轴方向)</span><br>    <br> __s32 value;<span class="hljs-comment">//事件值，如果type是按键，按下时value为1，松开时为0；如果是EV_REL，value			  //表示x,y方向上的偏移量；如果是EV_ABS，value表示x,y轴坐标值</span><br>    <br>&#125;;<br></code></pre></td></tr></table></figure>





<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">size_t</span> count = mEventHub-&gt;<span class="hljs-built_in">getEvents</span>(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">EventHub::getEvents</span><span class="hljs-params">(<span class="hljs-type">int</span> timeoutMillis, RawEvent* buffer, <span class="hljs-type">size_t</span> bufferSize)</span> </span>&#123;<br>    <span class="hljs-built_in">ALOG_ASSERT</span>(bufferSize &gt;= <span class="hljs-number">1</span>);<br><br>    std::scoped_lock _l(mLock);<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">input_event</span> readBuffer[bufferSize];<br><br>    RawEvent* event = buffer;<br>    <span class="hljs-type">size_t</span> capacity = bufferSize;<br>    <span class="hljs-type">bool</span> awoken = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">nsecs_t</span> now = <span class="hljs-built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC);<br><br>        <span class="hljs-comment">// 1.mNeedToReopenDevices初始化为false</span><br>        <span class="hljs-keyword">if</span> (mNeedToReopenDevices) &#123;<br>            mNeedToReopenDevices = <span class="hljs-literal">false</span>;<br><br>            <span class="hljs-built_in">ALOGI</span>(<span class="hljs-string">&quot;Reopening all input devices due to a configuration change.&quot;</span>);<br><br>            <span class="hljs-built_in">closeAllDevicesLocked</span>();<br>            mNeedToScanDevices = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>; <br>        &#125;<br><br>        <span class="hljs-comment">// 2.报告最近添加删除的设备，初始化时为mClosingDevices为空，不执行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = mClosingDevices.<span class="hljs-built_in">begin</span>(); it != mClosingDevices.<span class="hljs-built_in">end</span>();) &#123;<br>            std::unique_ptr&lt;Device&gt; device = std::<span class="hljs-built_in">move</span>(*it);<br>            <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;Reporting device closed: id=%d, name=%s\n&quot;</span>, device-&gt;id, device-&gt;path.<span class="hljs-built_in">c_str</span>());<br>            event-&gt;when = now;<br>            event-&gt;deviceId = (device-&gt;id == mBuiltInKeyboardId)<br>                    ? ReservedInputDeviceId::BUILT_IN_KEYBOARD_ID<br>                    : device-&gt;id;<br>            event-&gt;type = DEVICE_REMOVED;<br>            event += <span class="hljs-number">1</span>;<br>            it = mClosingDevices.<span class="hljs-built_in">erase</span>(it);<br>            mNeedToSendFinishedDeviceScan = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (--capacity == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <br>        <span class="hljs-comment">//3: mNeedToScanDevices初始化为true，scanDevicesLocked的调用过程：				//scanDevicesLocked() —-&gt; scanDirLocked(DEVICE_PATH) —-&gt; 					//openDeviceLocked(devname)</span><br>        <span class="hljs-keyword">if</span> (mNeedToScanDevices) &#123;<br>            mNeedToScanDevices = <span class="hljs-literal">false</span>;<br>            <span class="hljs-built_in">scanDevicesLocked</span>(); <span class="hljs-comment">//扫描设备</span><br>            mNeedToSendFinishedDeviceScan = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">//4把所有设备Device的内容保存到RawEvent结构体中，把event-&gt;type设为 				//DEVICE_ADDED，意味着事件被成功添加到RawEvent，再把								//mNeedToSendFinishedDeviceScan设为true，意味着结束设备扫描。</span><br>        <br>        <span class="hljs-keyword">while</span> (!mOpeningDevices.<span class="hljs-built_in">empty</span>()) &#123;<br>            std::unique_ptr&lt;Device&gt; device = std::<span class="hljs-built_in">move</span>(*mOpeningDevices.<span class="hljs-built_in">rbegin</span>());<br>            mOpeningDevices.<span class="hljs-built_in">pop_back</span>();<br>            <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;Reporting device opened: id=%d, name=%s\n&quot;</span>, device-&gt;id, device-&gt;path.<span class="hljs-built_in">c_str</span>());<br>            event-&gt;when = now;<br>            event-&gt;deviceId = device-&gt;id == mBuiltInKeyboardId ? <span class="hljs-number">0</span> : device-&gt;id;<br>            event-&gt;type = DEVICE_ADDED;<br>            event += <span class="hljs-number">1</span>;<br><br>            <span class="hljs-comment">// Try to find a matching video device by comparing device names</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = mUnattachedVideoDevices.<span class="hljs-built_in">begin</span>(); it != mUnattachedVideoDevices.<span class="hljs-built_in">end</span>();<br>                 it++) &#123;<br>                std::unique_ptr&lt;TouchVideoDevice&gt;&amp; videoDevice = *it;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">tryAddVideoDeviceLocked</span>(*device, videoDevice)) &#123;<br>                    <span class="hljs-comment">// videoDevice was transferred to &#x27;device&#x27;</span><br>                    it = mUnattachedVideoDevices.<span class="hljs-built_in">erase</span>(it);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">auto</span> [dev_it, inserted] = mDevices.<span class="hljs-built_in">insert_or_assign</span>(device-&gt;id, std::<span class="hljs-built_in">move</span>(device));<br>            <span class="hljs-keyword">if</span> (!inserted) &#123;<br>                <span class="hljs-built_in">ALOGW</span>(<span class="hljs-string">&quot;Device id %d exists, replaced.&quot;</span>, device-&gt;id);<br>            &#125;<br>            mNeedToSendFinishedDeviceScan = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (--capacity == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        ......<br>        ......<br>        ......<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述方法：扫描DEVICE_PATH(&#x2F;dev&#x2F;path)中设备节点，如图：</p>
<p><img src="D:\project\bolg\source_posts\安卓按键事件传递流程.assets\Snipaste_2023-12-08_16-44-57-1702025123208.png" srcset="/img/loading.gif" lazyload alt="Snipaste_2023-12-08_16-44-57"></p>
<p><strong>scanDevicesLocked()调用流程的一些函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventHub::scanDevicesLocked</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">status_t</span> result = <span class="hljs-built_in">scanDirLocked</span>(DEVICE_PATH); <span class="hljs-comment">//DEVICE_PATH = /dev/input</span><br>    <span class="hljs-keyword">if</span> (result &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;scan dir failed for %s&quot;</span>, DEVICE_PATH);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isV4lScanningEnabled</span>()) &#123;<br>        result = <span class="hljs-built_in">scanVideoDirLocked</span>(VIDEO_DEVICE_PATH);<br>        <span class="hljs-keyword">if</span> (result != OK) &#123;<br>            <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;scan video dir failed for %s&quot;</span>, VIDEO_DEVICE_PATH);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (mDevices.<span class="hljs-built_in">find</span>(ReservedInputDeviceId::VIRTUAL_KEYBOARD_ID) == mDevices.<span class="hljs-built_in">end</span>()) &#123;<br>        <span class="hljs-built_in">createVirtualKeyboardLocked</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//scanDirLocked()函数</span><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">EventHub::scanDirLocked</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; dirname)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; entry : std::filesystem::<span class="hljs-built_in">directory_iterator</span>(dirname)) &#123;<br>        <span class="hljs-built_in">openDeviceLocked</span>(entry.<span class="hljs-built_in">path</span>());<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// openDeviceLocked(entry.path());</span><br></code></pre></td></tr></table></figure>



<h6 id="1-15-openDeviceLocked-函数"><a href="#1-15-openDeviceLocked-函数" class="headerlink" title="1.15:openDeviceLocked()函数"></a>1.15:openDeviceLocked()函数</h6><p>其中有一条语句</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> fd = <span class="hljs-built_in">open</span>(devicePath.<span class="hljs-built_in">c_str</span>(), O_RDWR | O_CLOEXEC | O_NONBLOCK);<br><br><span class="hljs-comment">//devicePath是要打开的设备文件的路径，它是一个字符串类型的变量, c_str()是一个字符串成员函  //数，用于将C++的字符串转换为C风格的字符串（以null结尾的字符数组）</span><br><br><span class="hljs-comment">// O_RDWR表示以可读可写的方式打开文件</span><br><span class="hljs-comment">// O_CLOEXEC表示在执行exec函数时关闭文件描述符</span><br><span class="hljs-comment">// O_NONBLOCK表示以非阻塞的方式打开文件。</span><br></code></pre></td></tr></table></figure>



<p>openDeviceLocked函数中的一些操作：</p>
<ul>
<li>获取设备名称、</li>
<li>检查是否已经包含在容器mExcludedDevices中、</li>
<li>获取该设备的驱动版本、</li>
<li>获取设备身份信息保存到inputid结构体中并赋给InputDeviceIdentifier对象中的变量、</li>
<li>获取设备的物理地址和设备唯一id号，</li>
<li>设置文件描述符fd为非阻塞模式O_NONBLOCK属性等</li>
</ul>
<p>该函数中继续 —&gt; 创建Device对象表示该设备</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::unique_ptr&lt;Device&gt; device = std::<span class="hljs-built_in">make_unique</span>&lt;Device&gt;(fd, deviceId, devicePath, identifier);<br></code></pre></td></tr></table></figure>



<p>检查该设备是按键或键盘，就把设备对象的classes属性标为INPUT_DEVICE_CLASS_KEYBOARD，表示当前发生输入事件的设备是按键或键盘；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">bool</span> haveKeyboardKeys =device-&gt;keyBitmask.<span class="hljs-built_in">any</span>(<span class="hljs-number">0</span>, BTN_MISC) || device-&gt;keyBitmask.<span class="hljs-built_in">any</span>(BTN_WHEEL, KEY_MAX + <span class="hljs-number">1</span>);<br><br><span class="hljs-type">bool</span> haveGamepadButtons = device-&gt;keyBitmask.<span class="hljs-built_in">any</span>(BTN_MISC, BTN_MOUSE) ||device-&gt;keyBitmask.<span class="hljs-built_in">any</span>(BTN_JOYSTICK, BTN_DIGI);<br><br><span class="hljs-keyword">if</span> (haveKeyboardKeys || haveGamepadButtons) &#123;<br>    device-&gt;classes |= InputDeviceClass::KEYBOARD;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>最后 addDeviceLocked(std::move(device));</p>
<ul>
<li>把设备id、设备对象作为一对映射保存到mDevices容器中</li>
<li>并设device-&gt;next &#x3D; mOpeningDevices，mOpeningDevices初始化为0</li>
<li>表示下一个设备还没有，同时设mOpeningDevices为当前设备对象。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">addDeviceLocked</span>(std::<span class="hljs-built_in">move</span>(device));<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventHub::addDeviceLocked</span><span class="hljs-params">(Device* device)</span> </span>&#123;<br>    mDevices.<span class="hljs-built_in">add</span>(device-&gt;id, device);<br>    device-&gt;next = mOpeningDevices;<br>    mOpeningDevices = device;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>回到EventHub.getEvents()函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">while</span> (!mOpeningDevices.<span class="hljs-built_in">empty</span>()) &#123; ...... &#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>把所有设备Device的内容保存到RawEvent结构体中</li>
<li>把event-&gt;type设为DEVICE_ADDED，意味着事件被成功添加到RawEvent</li>
<li>再把mNeedToSendFinishedDeviceScan设为true，意味着结束设备扫描</li>
</ul>
<p>mPendingEventCount和mPendingEventIndex都初始化为0，while循环不成立，跳过该while循环</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">while</span> (mPendingEventIndex &lt; mPendingEventCount) &#123; ...... &#125;<br></code></pre></td></tr></table></figure>



<p>mPendingINotify初始化为false，跳过：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (mPendingINotify &amp;&amp; mPendingEventIndex &gt;= mPendingEventCount) &#123; ...... &#125;<br></code></pre></td></tr></table></figure>



<p>deviceChanged也为false，跳过：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (deviceChanged) &#123; ...... &#125;<br></code></pre></td></tr></table></figure>

<p>不相等，跳出循环</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(;;)&#123;<br>    <span class="hljs-keyword">if</span> (event != buffer || awoken) &#123;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>     <br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后返回获取的事件数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">return</span> event - buffer;<br></code></pre></td></tr></table></figure>



<p>因为InputReaderThread会反复执行，下次在执行时，就会执行到</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">mPendingEventIndex = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">int</span> pollResult = epoll<span class="hljs-constructor">_wait(<span class="hljs-params">mEpollFd</span>, <span class="hljs-params">mPendingEventItems</span>, EPOLL_MAX_EVENTS, <span class="hljs-params">timeoutMillis</span>)</span>;<br></code></pre></td></tr></table></figure>

<p>epoll_wait返回发生事件的个数赋给pollResult，pollResult肯定大于0，执行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">mPendingEventCount = <span class="hljs-built_in">size_t</span>(pollResult);<br></code></pre></td></tr></table></figure>



<p><strong>但是要使得epoll_wait执行，要向其管道中写入数据才行</strong></p>
<p>1.16：EventHub.wake函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventHub::wake</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;wake() called&quot;</span>);<br><br>    <span class="hljs-type">ssize_t</span> nWrite;<br>    <span class="hljs-keyword">do</span> &#123;<br>        nWrite = <span class="hljs-built_in">write</span>(mWakeWritePipeFd, <span class="hljs-string">&quot;W&quot;</span>, <span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">while</span> (nWrite == <span class="hljs-number">-1</span> &amp;&amp; errno == EINTR);<br><br>    <span class="hljs-keyword">if</span> (nWrite != <span class="hljs-number">1</span> &amp;&amp; errno != EAGAIN) &#123;<br>        <span class="hljs-built_in">ALOGW</span>(<span class="hljs-string">&quot;Could not write wake signal: %s&quot;</span>, <span class="hljs-built_in">strerror</span>(errno));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>在wake方法中，管道写入端mWakeWritePipeFd写入了一个字符w，</li>
<li>管道中有数据了，epoll机制监控到管道有I&#x2F;O事件发生，</li>
<li>于是epoll_wait执行，返回发生I&#x2F;O事件的个数，</li>
<li>并且把发生的事件放在epoll_event结构数组mPendingEventItems中，</li>
<li>调用者线程InputReaderThread被唤醒</li>
</ul>
<p><strong>问题：wake()是在哪里被调用的</strong></p>
<p>再次执行getEvents中的for循环</p>
<p>mOpeningDevices在1.5.3.1-1节中已经被赋为device-&gt;next即0，所以while循环：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-keyword">while</span> <span class="hljs-comment">(mClosingDevices)</span> &#123;<br></code></pre></td></tr></table></figure>

<p>不成立，跳过。</p>
<p>mPendingEventCount大于0了，mPendingEventIndex &lt; mPendingEventCount成立，进入到下面while循环：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-keyword">while</span> <span class="hljs-comment">(mPendingEventIndex &lt; mPendingEventCount)</span> &#123;<br></code></pre></td></tr></table></figure>

<p>根据发生事件的类型，判断：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">if (eventItem.data.u32 <span class="hljs-operator">=</span><span class="hljs-operator">=</span> EPOLL_ID_WAKE) &#123;<br></code></pre></td></tr></table></figure>

<p>成立，进程执行到：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">do</span> &#123;<br>    nRead = read(mWakeReadPipeFd, <span class="hljs-built_in">buffer</span>, sizeof(<span class="hljs-built_in">buffer</span>));<br>&#125; <span class="hljs-keyword">while</span> ((nRead == <span class="hljs-number">-1</span> &amp;&amp; errno == EINTR) || nRead == sizeof(<span class="hljs-built_in">buffer</span>));<br></code></pre></td></tr></table></figure>

<p>从管道中读取数据，该数据就是一个字符w，执行完后continue跳出循环，又执行到epoll_wait，InputReader又被阻塞等待</p>
<p>就这样一直循环，保证InputReader线程存活， 当一定的时间过去后，仍然没有输入事件，epoll_wait可能超时返回0，</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">if (pollResult <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">0</span>) &#123;  //epoll_wait返回<span class="hljs-number">0</span>，超时退出循环<br>    // Timed out.<br>    mPendingEventCount <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>    break<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>但是这样InputRead线程就不能保证及时获取到输入事件了，所以系统创建了watchdog线程，用于定时提醒InputReader线程读入输入事件</p>
<p>在1.10中InputManager.start()方法中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">Watchdog.<span class="hljs-built_in">getInstance</span>().<span class="hljs-built_in">addMonitor</span>(<span class="hljs-keyword">this</span>);<br></code></pre></td></tr></table></figure>



<h6 id="1-16-回到EventHub-getevents函数"><a href="#1-16-回到EventHub-getevents函数" class="headerlink" title="1.16: 回到EventHub.getevents函数"></a>1.16: 回到EventHub.getevents函数</h6><p>当有输入事件发生时，epoll_wait方法开始执行返回发生的个数赋给pollResult变量，此时pollResult肯定大于0，mPendingEventCount也大于0，继续for循环，进入到：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (mPendingEventIndex &lt; mPendingEventCount) &#123;<br></code></pre></td></tr></table></figure>

<p>此时eventItem.data.u32的值是设备id，if语句：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (eventItem.data.u32 == EPOLL_ID_INOTIFY) &#123;<br></code></pre></td></tr></table></figure>

<p>与</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (eventItem.data.u32 == EPOLL_ID_WAKE) &#123;<br></code></pre></td></tr></table></figure>

<p>都不成立，进程执行到：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">Device* device = mDevices.<span class="hljs-built_in">valueAt</span>(deviceIndex);<br><span class="hljs-keyword">if</span> (eventItem.events &amp; EPOLLIN) &#123;<br>    int32_treadSize = <span class="hljs-built_in">read</span>(device-&gt;fd, readBuffer, <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> input_event) * capacity);<br></code></pre></td></tr></table></figure>

<p>根据设备id从容器中取出设备对象，如果发生了可读事件，调用read从该设备文件中读取事件保存到readBuffer中，如果没出错的话，执行：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fsharp">int32_tdeviceId <span class="hljs-operator">=</span> device<span class="hljs-operator">-&gt;</span><span class="hljs-built_in">id</span> <span class="hljs-operator">==</span> mBuiltInKeyboardId <span class="hljs-operator">?</span> <span class="hljs-number">0</span> <span class="hljs-operator">:</span> device<span class="hljs-operator">-&gt;</span><span class="hljs-built_in">id</span>;<br>size_tcount <span class="hljs-operator">=</span> size_t(readSize) <span class="hljs-operator">/</span> <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> input_event);<br><span class="hljs-keyword">for</span> (size_t i <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i <span class="hljs-operator">&lt;</span> count; i<span class="hljs-operator">++</span>) &#123;<br>    <span class="hljs-keyword">struct</span> input_event<span class="hljs-operator">&amp;</span> iev <span class="hljs-operator">=</span> readBuffer[i];<br></code></pre></td></tr></table></figure>

<p>计算出有多少个事件并取出来保存到input_event结构体变量iev中，然后计算相应的事件执行时间，再把input_event结构体变量中的内容保存到原始事件RawEvent中，然后循环直到所有事件都被获取到后，进程执行：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// Return now if we have collected any events or if we were explicitly awoken.</span><br><span class="hljs-keyword">if</span> (event != <span class="hljs-built_in">buffer</span> || awoken) &#123;<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>event指向的内存现在已经保存了事件，而buffer还是指向首地址，不相等，if成立，执行break跳出for(::)无限循环，执行到getEvents最后一句：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">return</span> event - buffer;<br></code></pre></td></tr></table></figure>

<p>返回读取事件的个数，并返回到InputReader的loopOnce中这一句：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">size_t</span> count = mEventHub-&gt;<span class="hljs-built_in">getEvents</span>(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);<br></code></pre></td></tr></table></figure>

<p>count大于0，执行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (count) &#123;<br>    <span class="hljs-built_in">processEventsLocked</span>(mEventBuffer, count);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>调用processEventsLocked对事件进行处理，此处属于事件处理阶段</p>
<h6 id="1-17-总结一："><a href="#1-17-总结一：" class="headerlink" title="1.17 总结一："></a>1.17 总结一：</h6><ul>
<li>创建InputDispatchThread, InputReaderThread,InputManager等主要输入系统核心组件</li>
<li>扫描所有输入设备，获取输入设备各种信息</li>
<li>获取输入设备事件</li>
</ul>
<h4 id="2：Framework层获得按键事件后如何处理、存储"><a href="#2：Framework层获得按键事件后如何处理、存储" class="headerlink" title="2：Framework层获得按键事件后如何处理、存储"></a>2：Framework层获得按键事件后如何处理、存储</h4><hr>
<h6 id="2-1-processEventsDeviceLocked"><a href="#2-1-processEventsDeviceLocked" class="headerlink" title="2.1: processEventsDeviceLocked"></a>2.1: processEventsDeviceLocked</h6><p>通过上述getEvents获得事件后，执行过程：processEventsLocked —-&gt; processEventsForDeviceLocked</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//processEventsDeviceLocked</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InputReader::processEventsForDeviceLocked</span><span class="hljs-params">(int32_tdeviceId,</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-type">const</span> RawEvent* rawEvents, size_tcount)</span> </span>&#123;<br>ssize_tdeviceIndex = mDevices.<span class="hljs-built_in">indexOfKey</span>(deviceId);<br><span class="hljs-keyword">if</span> (deviceIndex &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">ALOGW</span>(<span class="hljs-string">&quot;Discarding event for unknown deviceId %d.&quot;</span>, deviceId);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br>InputDevice* device = mDevices.<span class="hljs-built_in">valueAt</span>(deviceIndex);<br><span class="hljs-keyword">if</span> (device-&gt;<span class="hljs-built_in">isIgnored</span>()) &#123;<br>    <span class="hljs-comment">//ALOGD(&quot;Discarding event for ignored deviceId %d.&quot;, deviceId);</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br>    device-&gt;<span class="hljs-built_in">process</span>(rawEvents, count);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>之后的调用过程: device-&gt;process(rawEvents, count) —-&gt; mapper-&gt;process(rawEvent) —-&gt; KeyboardInputMapper::processKey</p>
<h6 id="2-2-InputDispatcher-cpp的notifyKey函数"><a href="#2-2-InputDispatcher-cpp的notifyKey函数" class="headerlink" title="2.2: InputDispatcher.cpp的notifyKey函数"></a>2.2: InputDispatcher.cpp的notifyKey函数</h6><p>​	对传递过来的按键事件进行检查、验证，之后处理特殊按键，再把按键放到InboundQueue队列中，最后调用Looper对象的wake像管道中写入字符W一样去 **唤醒InputDispatcherThread线程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InputDispatcher::notifyKey</span><span class="hljs-params">(<span class="hljs-type">const</span> NotifyKeyArgs* args)</span> </span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DEBUG_INBOUND_EVENT_DETAILS</span><br>    <span class="hljs-built_in">ALOGD</span>(<span class="hljs-string">&quot;notifyKey - eventTime=%lld, deviceId=%d, source=0x%x, policyFlags=0x%x, action=0x%x, &quot;</span><br>            <span class="hljs-string">&quot;flags=0x%x, keyCode=0x%x, scanCode=0x%x, metaState=0x%x, downTime=%lld&quot;</span>,<br>            args-&gt;eventTime, args-&gt;deviceId, args-&gt;source, args-&gt;policyFlags,<br>            args-&gt;action, args-&gt;flags, args-&gt;keyCode, args-&gt;scanCode,<br>            args-&gt;metaState, args-&gt;downTime);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">validateKeyEvent</span>(args-&gt;action)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br> <br>    uint32_tpolicyFlags = args-&gt;policyFlags;<br>    int32_tflags = args-&gt;flags;<br>    int32_tmetaState = args-&gt;metaState;<br>    <span class="hljs-keyword">if</span> ((policyFlags &amp; POLICY_FLAG_VIRTUAL) || (flags &amp; AKEY_EVENT_FLAG_VIRTUAL_HARD_KEY)) &#123;<br>        policyFlags |= POLICY_FLAG_VIRTUAL;<br>        flags |= AKEY_EVENT_FLAG_VIRTUAL_HARD_KEY;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (policyFlags &amp; POLICY_FLAG_FUNCTION) &#123;<br>        metaState |= AMETA_FUNCTION_ON;<br>    &#125;<br> <br>    policyFlags |= POLICY_FLAG_TRUSTED;<br> <br>    int32_tkeyCode = args-&gt;keyCode;<br>    <span class="hljs-keyword">if</span> (metaState &amp; AMETA_META_ON &amp;&amp; args-&gt;action == AKEY_EVENT_ACTION_DOWN) &#123;<br>        int32_tnewKeyCode = AKEYCODE_UNKNOWN;<br>        <span class="hljs-keyword">if</span> (keyCode == AKEYCODE_DEL) &#123;<br>            newKeyCode = AKEYCODE_BACK;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (keyCode == AKEYCODE_ENTER) &#123;<br>            newKeyCode = AKEYCODE_HOME;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (newKeyCode != AKEYCODE_UNKNOWN) &#123;<br>            <span class="hljs-built_in">AutoMutex_l</span>(mLock);<br>            <span class="hljs-keyword">struct</span> <span class="hljs-title class_">KeyReplacementreplacement</span> = &#123;keyCode, args-&gt;deviceId&#125;;<br>            mReplacedKeys.<span class="hljs-built_in">add</span>(replacement, newKeyCode);<br>            keyCode = newKeyCode;<br>            metaState &amp;= ~AMETA_META_ON;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (args-&gt;action == AKEY_EVENT_ACTION_UP) &#123;<br>        <span class="hljs-comment">// In order to maintain a consistent stream of up and down events, check to see if the key</span><br>        <span class="hljs-comment">// going up is one we&#x27;ve replaced in a down event and haven&#x27;t yet replaced in an up event,</span><br>        <span class="hljs-comment">// even if the modifier was released between the down and the up events.</span><br>        <span class="hljs-built_in">AutoMutex_l</span>(mLock);<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">KeyReplacementreplacement</span> = &#123;keyCode, args-&gt;deviceId&#125;;<br>        ssize_tindex = mReplacedKeys.<span class="hljs-built_in">indexOfKey</span>(replacement);<br>        <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span>) &#123;<br>            keyCode = mReplacedKeys.<span class="hljs-built_in">valueAt</span>(index);<br>            mReplacedKeys.<span class="hljs-built_in">removeItemsAt</span>(index);<br>            metaState &amp;= ~AMETA_META_ON;<br>        &#125;<br>    &#125;<br> <br>    KeyEventevent;<br>    event.<span class="hljs-built_in">initialize</span>(args-&gt;deviceId, args-&gt;source, args-&gt;action,<br>            flags, keyCode, args-&gt;scanCode, metaState, <span class="hljs-number">0</span>,<br>            args-&gt;downTime, args-&gt;eventTime);<br> <br>    mPolicy-&gt;<span class="hljs-built_in">interceptKeyBeforeQueueing</span>(&amp;event, <span class="hljs-comment">/*byref*/</span> policyFlags);<br> <br>    <span class="hljs-type">bool</span> needWake;<br>    &#123; <span class="hljs-comment">// acquire lock</span><br>        mLock.<span class="hljs-built_in">lock</span>();<br> <br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">shouldSendKeyToInputFilterLocked</span>(args)) &#123;<br>            mLock.<span class="hljs-built_in">unlock</span>();<br> <br>            policyFlags |= POLICY_FLAG_FILTERED;<br>            <span class="hljs-keyword">if</span> (!mPolicy-&gt;<span class="hljs-built_in">filterInputEvent</span>(&amp;event, policyFlags)) &#123;<br>                <span class="hljs-keyword">return</span>; <span class="hljs-comment">// event was consumed by the filter</span><br>            &#125;<br> <br>            mLock.<span class="hljs-built_in">lock</span>();<br>        &#125;<br> <br>        int32_trepeatCount = <span class="hljs-number">0</span>;<br>        KeyEntry* newEntry = <span class="hljs-keyword">new</span> <span class="hljs-built_in">KeyEntry</span>(args-&gt;eventTime,<br>                args-&gt;deviceId, args-&gt;source, policyFlags,<br>                args-&gt;action, flags, keyCode, args-&gt;scanCode,<br>                metaState, repeatCount, args-&gt;downTime);<br> <br>        needWake = <span class="hljs-built_in">enqueueInboundEventLocked</span>(newEntry);<br>        mLock.<span class="hljs-built_in">unlock</span>();<br>    &#125; <span class="hljs-comment">// release lock</span><br> <br>    <span class="hljs-keyword">if</span> (needWake) &#123;<br>        mLooper-&gt;<span class="hljs-built_in">wake</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>该函数做了很重要的任务：前半部分对传递过来的按键事件进行检查、验证，之后处理特殊按键，再把按键放到InboundQueue队列中，最后调用Looper对象的wake像管道中写入字符唤醒InputDispatcherThread线程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">validateKeyEvent</span>(args-&gt;action)) &#123;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>检查按键是否按下、松开</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> ((policyFlags &amp; POLICY_FLAG_VIRTUAL) || (flags &amp; AKEY_EVENT_FLAG_VIRTUAL_HARD_KEY)) &#123;<br>    policyFlags |= POLICY_FLAG_VIRTUAL;<br>    flags |= AKEY_EVENT_FLAG_VIRTUAL_HARD_KEY;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>设置flags标致为AKEY_EVENT_FLAG_VIRTUAL_HARD_KEY，虚拟硬件，比如手机上除了屏幕显示外的MENU、HOME、BACK键</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (policyFlags &amp; POLICY_FLAG_FUNCTION) &#123;<br>    metaState |= AMETA_FUNCTION_ON;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>设置metaState为meta键标志</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">policyFlags |= POLICY_FLAG_TRUSTED;<br></code></pre></td></tr></table></figure>

<p>设置该标志表示按键事件是可信任的，比如，一个直接与Android机器相连接的按键设备</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">KeyEventevent;<br>event.<span class="hljs-built_in">initialize</span>(args-&gt;deviceId, args-&gt;source, args-&gt;action, flags, keyCode, args-&gt;scanCode, metaState, <span class="hljs-number">0</span>, args-&gt;downTime, args-&gt;eventTime);<br></code></pre></td></tr></table></figure>

<p>把参数传递给KeyEvent对象event</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">mPolicy-&gt;<span class="hljs-built_in">interceptKeyBeforeQueueing</span>(&amp;event, <span class="hljs-comment">/*byref*/</span> policyFlags);<br></code></pre></td></tr></table></figure>

<p>拦截按键进行特殊处理，比如HOME、音量键、拨号键，电源等</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">needWake = <span class="hljs-built_in">enqueueInboundEventLocked</span>(newEntry);<br></code></pre></td></tr></table></figure>

<p><strong>创建KeyEntry对象并把按键事件作为该对象的内容</strong>，enqueueInboundEventLocked函数根据输入事件的类型作进一步处理：</p>
<p>mInboundQueue一开始没有数据为空，enqueueAtTail函数把按键事件对象KeyEntry插入到mInboundQueue队尾。</p>
<p>case语句用来切换app，如果是HOME、挂号按键，就把needWake设为true，表示可以唤醒InputDispatcherThread来分发按键事件，否则，不唤醒InputDispatcherThread，那么按键就不会处理</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (needWake) &#123;<br>    mLooper-&gt;<span class="hljs-built_in">wake</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>wake函数会调用write系统调用向管道中写入数据唤醒读端线程，读端线程是谁？</p>
<p>InputDispatcherThread线程执行到了Looper对象的pollOnce函数时处于阻塞状态，此时epoll机制检测到管道中有数据写入事件发生，由Handler机制可知，读端线程InputDispatcherThread被唤醒，InputDispatcherThread线程从dispatchOnce返回到threadLoop，threadLoop的返回值为true，表明是线程是循环执行的，又一次调用dispatchOnce继续执行。唤醒了InputDispatcherThread</p>
<p>小结：</p>
<p>把获取的原始按键码值转化成应用层按键值，对按键事件进行检查，处理特殊按键，最后把按键事件封装成EventEntry后临时存储到InboundQueue队列中等待处理。</p>
<p>现在，按键事件读取后的处理已经完成，cpu就把控制权从InputReaderThread交给了InputDispatcherThread线程，开始分发事件。</p>
<h4 id="3-Framework层如何分发按键事件传递给应用层"><a href="#3-Framework层如何分发按键事件传递给应用层" class="headerlink" title="3: Framework层如何分发按键事件传递给应用层"></a>3: Framework层如何分发按键事件传递给应用层</h4><hr>
<p>​	由上述可知,当前的InputDispatchThread线程被唤醒, 且由1.10和1.11中可知,会执行到其dispatchOnce方法</p>
<p>并执行到dispatchOnceInnerLocked方法</p>
<p>​	在dispatchOnce方法中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">haveCommandsLocked</span>()) &#123;<br>	<span class="hljs-built_in">dispatchOnceInnerLocked</span>(&amp;nextWakeupTime);<br>&#125;<br></code></pre></td></tr></table></figure>

<h6 id="3-1-dispatchOnceInnerLocked函数"><a href="#3-1-dispatchOnceInnerLocked函数" class="headerlink" title="3.1: dispatchOnceInnerLocked函数"></a>3.1: dispatchOnceInnerLocked函数</h6>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/12/18/Leanback%E5%BA%93%E4%BD%BF%E7%94%A8/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Leanback库使用</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/09/27/Android%E4%B8%B2%E5%8F%A3%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4/">
                        <span class="hidden-mobile">串口调试命令</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <i class="iconfont icon-love"></i>lier 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
